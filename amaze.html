<!DOCTYPE html>
<html>
<head>
  <style>
  body{
    background: #586da1;
  }
  .board{
    display: flex;
  }
  .square{
    width: 25px;
    height: 25px;
    position: absolute;
  }
  .player{
    width: 25px;
    height: 25px;
    border-radius: 100%;
    background: yellow;
    position: absolute;
    left: 0px;
    top: 0px;
    z-index: 1;
    opacity: 1;
    transition: opacity .25s;
    transition: width .25s;
    transition: height .25s;
  }
  .teleport{
    width: 25px;
    height: 25px;
    border-radius: 100%;
    background: #000;
  }
  .player.moving{
    opacity: .7;
    width: 15px;
    height: 15px;
  }





  @keyframes playerCantMove{
    0%{
      background: yellow;
    }
    50%{
      background: red;
    }
    100%{
      background: yellow;
    }
  }
  </style>
</head>
<body>
  <div class="board">
    <div class="player"></div>
  </div>
<script>
const LEFT = 'ArrowLeft';
const RIGHT = 'ArrowRight';
const UP = 'ArrowUp';
const DOWN = 'ArrowDown';


const board = document.querySelector('.board');

let playerPos = [0, 0];

  function handleKeyDown(e){
    let newPlayerPos;
    if(e.code === LEFT){
      newPlayerPos = [playerPos[0], playerPos[1] - 1];
      if(!isAvailableSpaceNew(newPlayerPos[0], newPlayerPos[1], grid)){
        renderPlayerCantMove();
        return;
      } else {
        playerPos = newPlayerPos;
      }
    } else if (e.code === RIGHT){
      newPlayerPos = [playerPos[0], playerPos[1] + 1];
      if(!isAvailableSpaceNew(newPlayerPos[0], newPlayerPos[1], grid)){
        renderPlayerCantMove();
        return;
      } else {
        playerPos = newPlayerPos;
      }
    } else if (e.code === UP){
      newPlayerPos = [playerPos[0] - 1, playerPos[1]];
      if(!isAvailableSpaceNew(newPlayerPos[0], newPlayerPos[1], grid)){
        renderPlayerCantMove();
        return;
      } else {
        playerPos = newPlayerPos;
      }
    } else if (e.code === DOWN){
      newPlayerPos = [playerPos[0] + 1, playerPos[1]];
      if(!isAvailableSpaceNew(newPlayerPos[0], newPlayerPos[1], grid)){
        renderPlayerCantMove();
        return;
      } else {
        playerPos = newPlayerPos;
      }
    }
    renderPlayer(playerPos[0], playerPos[1]);
  }



  function renderPlayer(newRow, newCol, time){
    let renderedPlayer = document.querySelector('.player');

    if(playerPos[0] !== newRow){

    } else {

    }
    renderedPlayer.style.top = newRow * 25 + 'px';
    renderedPlayer.style.left = newCol * 25 + 'px';
    renderedPlayer.style.transition = 'left top .25s';
    renderedPlayer.style.transition = 'top .25s';
  }

  function renderPlayerCantMove(){
    let renderedPlayer = document.querySelector('.player');
    renderedPlayer.style.animation = 'playerCantMove .25s ease';
    setTimeout(function(){
      renderedPlayer.style.animation = 'none';
    }, 500);
  }

  function isAvailableSpace(row, col, yourGrid){
    try{
      yourGrid[row][col];
    } catch {
      return false;
    }
    if(!yourGrid[row][col]){
      return false;
    }
    if(yourGrid[row][col] === 'X'){
      return false;
    } else if(yourGrid[row][col] === 'O') {
      return true;
    }
    return true;
  }

  function isAvailableSpaceNew(row, col){
    // try{
    //   yourGrid[row][col];
    // } catch {
    //   return false;
    // }
    // if(!yourGrid[row][col]){
    //   return false;
    // }
    let currPos = playerPos.slice("");
    // getFourCorners(row, col)
    let currCorners = getFourCorners(playerPos[0], playerPos[1]);
    let newCorners = getFourCorners(row, col);

    //optimize!
    let sharedPoints = [];
    for(let i = 0; i < currCorners.length; i++){
      for(let j = 0; j < newCorners.length; j++){
        if(currCorners[i][0] === newCorners[j][0] && currCorners[i][1] === newCorners[j][1]){
          sharedPoints.push(currCorners[i]);
        }
      }
    }
    console.log('sharedPoints', sharedPoints);

    // uses global edges
    let edgeKeys = [
      `${sharedPoints[0][0]},${sharedPoints[0][1]}:${sharedPoints[1][0]},${sharedPoints[1][1]}`,
      `${sharedPoints[1][0]},${sharedPoints[1][1]}:${sharedPoints[0][0]},${sharedPoints[0][1]}`,
    ];
    console.log(edgeKeys);

    for(let i = 0; i < edgeKeys.length; i++){
      if(edges[edgeKeys[i]] === true){
        console.log('wall!')
        return false;
      }
    }
    return true;

    // get shared points

  }

  window.addEventListener('keydown', handleKeyDown);

  function createSquareGrid(n){
      let buildGrid = [];
      for(let i = 0; i < n; i++){
        let row = [];
        for(let j = 0; j < n; j++){
          let randInt = Math.floor(Math.random() * 3);
          if(randInt === 0){
            row.push('X');
          } else {
            row.push('O');
          }
        }
        buildGrid.push(row);
      }
      buildGrid[0][0] = 'T';
      return buildGrid;
  }

function checkInArray(x, y, arr){
  for(let i = 0; i < arr.length; i++){
    if(arr[i][0] === x && arr[i][1] === y){
      return true;
    }
    return false;
  }
}

function genEdgeObj(n){
  let pointsArr = [];
  let edges = {};
  for(let i = 0; i < n; i++){
    for(let j = 0; j < n; j++){
      pointsArr.push([i,j]);
    }
  }
  for(let i = 0; i < pointsArr.length; i++){
    for(let j = 0; j < pointsArr.length; j++){
      console.log(pointsArr[i][0], pointsArr[j][0], pointsArr[i][1], pointsArr[j][1]);

      if(pointsArr[i][0] === pointsArr[j][0] && pointsArr[i][1] === pointsArr[j][1]){
        console.log('skip');
      } else {
        let randChoice = Math.floor(Math.random() * 4);
        if(randChoice === 1){
          edges[`${pointsArr[i]}:${pointsArr[j]}`] = true;
        } else {
          edges[`${pointsArr[i]}:${pointsArr[j]}`] = false;
        }
      }

    }
  }
  return edges;
}

function genEdgeObjNew(n){
  let pointsArr = [];
  let newEdges = {};
  for(let i = 0; i < n; i++){
    for(let j = 0; j < n; j++){
      pointsArr.push([i,j]);
    }
  }
  console.log(pointsArr);

  for(let j = 0; j < pointsArr.length; j++){
    let connections = genConnectingPoints(pointsArr[j][0], pointsArr[j][1], grid);
    console.log(connections);
    for(let i = 0; i < connections.length; i++){
      let randInt = Math.floor(Math.random() * 4);
      if(randInt === 0){
        newEdges[`${pointsArr[j][0]},${pointsArr[j][1]}:${connections[i][0]},${connections[i][1]}`] = true;
      } else {
        newEdges[`${pointsArr[j][0]},${pointsArr[j][1]}:${connections[i][0]},${connections[i][1]}`] = false;
      }
    }
  }

  // if(pointsArr[i][0] === pointsArr[j][0] && pointsArr[i][1] === pointsArr[j][1]){
  //   console.log('should skip');
  // } else {
  //   let randChoice = Math.floor(Math.random() * 4);
  //   if(randChoice === 1){
  //     edges[`${pointsArr[i]}:${pointsArr[j]}`] = true;
  //   } else {
  //     edges[`${pointsArr[i]}:${pointsArr[j]}`] = false;
  //   }
  // }

  return newEdges;

}

function genConnectingPoints(row, col, grid){
  let maxPoint = grid.length;
  let connections = [];
  if(row + 1 < maxPoint){
    connections.push([row +1, col]);
  }
  if(row - 1 >= 0){
    connections.push([row -1, col]);
  }
  if(col + 1 < maxPoint){
    connections.push([row, col +1]);
  }
  if(col - 1 >= 0){
    connections.push([row, col-1]);
  }
  return connections;
}

function getFourCorners(row, col){
  let corners = [[row,col]];
  corners.push([row, col + 1]);
  corners.push([row + 1, col + 1]);
  corners.push([row + 1, col]);
  return corners;
}

function genBorderBools(corners, edges){
  let top = `${corners[0][0]},${corners[0][1]}:${corners[1][0]},${corners[1][1]}`;
  let right = `${corners[1][0]},${corners[1][1]}:${corners[2][0]},${corners[2][1]}`;
  let bottom = `${corners[2][0]},${corners[2][1]}:${corners[3][0]},${corners[3][1]}`
  let left = `${corners[3][0]},${corners[3][1]}:${corners[0][0]},${corners[0][1]}`
  return [
    edges[top] ? 2 : 0,
    edges[right] ? 2 : 0,
    edges[bottom] ? 2 : 0,
    edges[left] ? 2 : 0,
  ];
}

function setTeleports(grid){
  let gridSize = grid.length;
  let randChoice = Math.floor(Math.random() * gridSize);
  let secondRandChoice = Math.floor(Math.random() * gridSize);
  while(secondRandChoice === randChoice){
    secondRandChoice = Math.floor(Math.random() * gridSize);
  }

}

function drawGrid(coordinates){
  for(let row = 0; row < coordinates.length; row++){
    for(let col = 0; col < coordinates[0].length; col++){
      let leftPos = col * 25;
      let topPos = row * 25;
      const spaceState = coordinates[row][col] === 'X' ? 'filled' : 'empty';
      let space =
      `<div
        class="${spaceState}"
        style="
          left: ${leftPos}px;
          top: ${topPos}px;
        ">
      </div>`;
      board.innerHTML += space;
    }
  }
}

function newDrawGrid(grid, graph){
  // getFourCorners(row, col)
  // genBorderBools(corners, edges)
  for(let row = 0; row < grid.length; row++){
    for(let col = 0; col < grid[0].length; col++){
      let leftPos = col * 25;
      let topPos = row * 25;
      let corners = getFourCorners(row, col);
      let borders = genBorderBools(corners, edges);
      let space =
      `<div
        class="square"
        style="
          left: ${leftPos}px;
          top: ${topPos}px;
          border-top: ${borders[0]}px solid #fff;
          border-right: ${borders[1]}px solid #fff;
          border-bottom: ${borders[2]}px solid #fff;
          border-left: ${borders[3]}px solid #fff;
        ">
      </div>`;
      board.innerHTML += space;
    }
  }
}

const grid = createSquareGrid(17);
// const edges = genEdgeObj(7);
// console.log(Object.keys(edges).length);
// console.log(edges);
// newDrawGrid(grid);


const edges = genEdgeObjNew(17);
newDrawGrid(grid);

console.log("newGenEdge: ", newGenEdge);

console.log(Object.keys(newGenEdge).length);

</script>
</body>
</html>
